class t{constructor(t,e){this.request=t,this.next=e}async handle(){const t=this.chain();for(let e of t){const t=await this.run(e);if(void 0!==t)return this.next(t)}return this.next()}run(t){return new Promise((e=>{t(this.request.to,this.request.from,e)}))}chain(){const t=new Set;for(let e of this.request.to.matched)e.meta.hasOwnProperty(o.guard)&&e.meta[o.guard].forEach(Set.prototype.add,t);return Array.from(t)}}var e=(e,r,a)=>{new t({to:e,from:r},a).handle()},r=t=>(e,r,a)=>{t(e,r,a)},a=t=>{let e=null;const r=(a,n,h)=>{let s=!1;if(e&&e.from.path===n.path&&e.to.matched[e.to.matched.length-1].path!==a.matched[a.matched.length-1].path&&(s=!0),e=s?null:{to:a,from:n},s)return h();for(let t in n.matched)if(n.matched[t].meta.hasOwnProperty(o.guard)&&n.matched[t].meta[o.guard].includes(r)&&n.matched[t]===a.matched[t])return h();t(a,n,h)};return r},n=t=>{const e=(r,a,n)=>{for(let h in a.matched)if(a.matched[h].meta.hasOwnProperty(o.guard)&&a.matched[h].meta[o.guard].includes(e)&&a.matched[h]===r.matched[h])return t(r,a,n);n()};return e};const o={guard:"guard"};function h(t,r){if(!0!==Boolean(r)||!0!==r.hasOwnProperty("router"))throw new Error("A Vue Router instance must be given to vue-router-shield");r.hasOwnProperty("guard")&&(o.guard=r.guard),r.router.beforeEach(e)}export{o as Settings,h as default,r as BeforeEach,a as BeforeEnter,n as BeforeUpdate};
//# sourceMappingURL=index.esm.js.map
